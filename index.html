<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Te amo infinitamente Cele üåπ</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    width: 100%; height: 100%;
    background: linear-gradient(135deg, #1e1e2f 0%, #12121b 100%);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #f8e8f8;
    display: flex;
    justify-content: center;
    align-items: center;
    user-select: none;
  }

  #container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
  }

  #centerText {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2.6rem;
    font-style: italic;
    font-weight: 600;
    color: #fddde6;
    text-align: center;
    max-width: 320px;
    text-shadow:
      0 0 8px rgba(255,192,203,0.9),
      0 0 16px rgba(255,105,180,0.6);
    pointer-events: none;
    animation: textGlow 4s ease-in-out infinite;
    line-height: 1.3;
    font-family: 'Dancing Script', cursive;
  }

  @keyframes textGlow {
    0%, 100% {
      text-shadow:
        0 0 8px rgba(255,192,203,0.9),
        0 0 16px rgba(255,105,180,0.6);
      color: #fddde6;
    }
    50% {
      text-shadow:
        0 0 14px rgba(255,182,193,1),
        0 0 26px rgba(255,105,180,0.8);
      color: #ffc0cb;
    }
  }

  @import url('https://fonts.googleapis.com/css2?family=Dancing+Script&display=swap');
</style>
</head>
<body>
  <div id="container"></div>
  <div id="centerText">te amo<br>infinitamente<br>cele</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script>
    (() => {
      const container = document.getElementById('container');
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.5, 6);

      const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0);
      container.appendChild(renderer.domElement);

      // Luces
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffa6c1, 1);
      directionalLight.position.set(5, 10, 7);
      scene.add(directionalLight);

      // Crear p√©talo de rosa (forma 2D con extrusi√≥n)
      function createPetal() {
        const shape = new THREE.Shape();
        shape.moveTo(0,0);
        shape.bezierCurveTo(0.2,0.8, 0.8,1.2, 0,1.5);
        shape.bezierCurveTo(-0.8,1.2, -0.2,0.8, 0,0);
        const extrudeSettings = {
          depth: 0.15,
          bevelEnabled: true,
          bevelThickness: 0.05,
          bevelSize: 0.05,
          bevelSegments: 3,
        };
        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geometry.rotateX(Math.PI / 2);
        return geometry;
      }

      // Crear tallo (cilindro delgado verde)
      function createStem(height=1.5) {
        const geometry = new THREE.CylinderGeometry(0.05, 0.05, height, 12);
        const material = new THREE.MeshPhongMaterial({color: 0x228822, shininess: 30});
        const stem = new THREE.Mesh(geometry, material);
        stem.position.y = -height/2;
        return stem;
      }

      // Crear rosa grande
      const petalsGroup = new THREE.Group();
      const petalGeometry = createPetal();
      const petalMaterial = new THREE.MeshPhongMaterial({
        color: 0xff3366,
        shininess: 100,
        specular: 0xff99aa,
        flatShading: false,
      });

      const petalCount = 12;
      for(let i=0; i<petalCount; i++){
        const petalMesh = new THREE.Mesh(petalGeometry, petalMaterial);
        petalMesh.position.y = 0;
        petalMesh.rotation.z = (i * (Math.PI * 2 / petalCount));
        petalMesh.position.x = Math.sin(i * (Math.PI * 2 / petalCount)) * 0.5;
        petalMesh.position.z = Math.cos(i * (Math.PI * 2 / petalCount)) * 0.5;
        petalMesh.rotation.x = 0.5 + Math.sin(i) * 0.2;
        petalsGroup.add(petalMesh);
      }

      // A√±adir tallo a la rosa grande
      const bigStem = createStem(2.2);
      petalsGroup.add(bigStem);

      petalsGroup.position.y = 0;
      scene.add(petalsGroup);

      // Rosas peque√±as con tallos
      const smallPetalMaterial = new THREE.MeshPhongMaterial({
        color: 0xff6699,
        shininess: 60,
        specular: 0xff99aa,
        transparent: true,
        opacity: 0.5
      });

      const smallRoses = [];
      for(let i=0; i<25; i++){
        const roseGroup = new THREE.Group();

        const smallPetalGeometry = createPetal();

        const petalsPerSmallRose = 7 + Math.floor(Math.random() * 4);
        for(let j=0; j<petalsPerSmallRose; j++){
          const petal = new THREE.Mesh(smallPetalGeometry, smallPetalMaterial);
          petal.position.y = 0;
          petal.rotation.z = (j * (Math.PI * 2 / petalsPerSmallRose));
          petal.position.x = Math.sin(j * (Math.PI * 2 / petalsPerSmallRose)) * 0.2;
          petal.position.z = Math.cos(j * (Math.PI * 2 / petalsPerSmallRose)) * 0.2;
          petal.rotation.x = 0.3 + Math.sin(j) * 0.15;
          roseGroup.add(petal);
        }

        // A√±adir tallo peque√±o
        const stem = createStem(1.1);
        roseGroup.add(stem);

        roseGroup.position.set(
          (Math.random()-0.5) * 8,
          (Math.random()-0.3) * 5,
          (Math.random()-0.5) * 8
        );
        const scale = 0.2 + Math.random() * 0.25;
        roseGroup.scale.set(scale, scale, scale);

        scene.add(roseGroup);
        smallRoses.push(roseGroup);
      }

      // Part√≠culas sutiles fondo
      const particleCount = 150;
      const particlesGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount*3);
      for(let i=0; i<particleCount; i++){
        positions[i*3] = (Math.random()-0.5)*20;
        positions[i*3+1] = (Math.random()-0.5)*10;
        positions[i*3+2] = (Math.random()-0.5)*20;
      }
      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
      const particlesMaterial = new THREE.PointsMaterial({
        color: 0xffc0cb,
        size: 0.06,
        transparent: true,
        opacity: 0.08
      });
      const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
      scene.add(particleSystem);

      // Animaci√≥n
      const clock = new THREE.Clock();

      function animate(){
        requestAnimationFrame(animate);
        const elapsed = clock.getElapsedTime();

        // Rosa grande: rotaci√≥n lenta y suave latido (p√©talos abri√©ndose)
        petalsGroup.rotation.y += 0.004;
        const scale = 1 + 0.03 * Math.sin(elapsed * 2);
        petalsGroup.scale.set(scale, scale, scale);

        // Rosas peque√±as flotando y rotando suavemente
        smallRoses.forEach((rose, i) => {
          rose.position.x += 0.0015 * Math.sin(elapsed + i);
          rose.position.y += 0.001 * Math.cos(elapsed * 1.3 + i);
          rose.position.z += 0.001 * Math.sin(elapsed * 0.8 + i * 1.5);
          rose.rotation.x += 0.004 + 0.002 * Math.sin(elapsed + i);
          rose.rotation.y += 0.005 + 0.002 * Math.cos(elapsed * 1.2 + i);
        });

        // Part√≠culas suben lentamente
        const pos = particlesGeometry.attributes.position.array;
        for(let i=0; i<particleCount; i++){
          pos[i*3+1] += 0.0003;
          if(pos[i*3+1] > 5) pos[i*3+1] = -5;
        }
        particlesGeometry.attributes.position.needsUpdate = true;

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    })();
  </script>
</body>
</html>
