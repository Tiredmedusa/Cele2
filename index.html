<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Te amo infinitamente Cele ❤️</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    width: 100%; height: 100%;
    background: linear-gradient(135deg, #1e1e2f 0%, #12121b 100%);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #f8e8f8;
    display: flex;
    justify-content: center;
    align-items: center;
    user-select: none;
  }

  #container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
  }

  #centerText {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2.6rem;
    font-style: italic;
    font-weight: 600;
    color: #fddde6;
    text-align: center;
    max-width: 320px;
    text-shadow:
      0 0 8px rgba(255,192,203,0.9),
      0 0 16px rgba(255,105,180,0.6);
    pointer-events: none;
    animation: textGlow 4s ease-in-out infinite;
    line-height: 1.3;
    font-family: 'Dancing Script', cursive;
  }

  @keyframes textGlow {
    0%, 100% {
      text-shadow:
        0 0 8px rgba(255,192,203,0.9),
        0 0 16px rgba(255,105,180,0.6);
      color: #fddde6;
    }
    50% {
      text-shadow:
        0 0 14px rgba(255,182,193,1),
        0 0 26px rgba(255,105,180,0.8);
      color: #ffc0cb;
    }
  }

  @import url('https://fonts.googleapis.com/css2?family=Dancing+Script&display=swap');
</style>
</head>
<body>
  <div id="container"></div>
  <div id="centerText">te amo<br>infinitamente<br>cele</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script>
    (() => {
      const container = document.getElementById('container');
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 7;

      const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0);
      container.appendChild(renderer.domElement);

      // Luces
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
      scene.add(ambientLight);

      const pointLight1 = new THREE.PointLight(0xffa6c1, 1.1);
      pointLight1.position.set(5,5,5);
      scene.add(pointLight1);

      const pointLight2 = new THREE.PointLight(0xff5c8a, 0.9);
      pointLight2.position.set(-5,-5,5);
      scene.add(pointLight2);

      // Crear forma 2D de corazón para extrusión
      function createHeartShape() {
        const shape = new THREE.Shape();
        shape.moveTo(0, 0);
        shape.bezierCurveTo(0, 0, 1, 1.2, 0, 3);
        shape.bezierCurveTo(0, 5, -3, 5, -3, 3.5);
        shape.bezierCurveTo(-3, 1.5, -1, 0, 0, 0);
        return shape;
      }

      const heartShape = createHeartShape();

      // Extrusión para volumen
      const extrudeSettings = {
        depth: 0.3,
        bevelEnabled: true,
        bevelThickness: 0.1,
        bevelSize: 0.1,
        bevelSegments: 5
      };

      // Corazón grande
      const heartGeometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
      const heartMaterial = new THREE.MeshPhongMaterial({
        color: 0xff4f79,
        shininess: 120,
        specular: 0xffaac2,
        flatShading: false,
      });
      const heartMesh = new THREE.Mesh(heartGeometry, heartMaterial);

      // Centrar y escalar corazón grande para que quede centrado y proporcionado
      heartGeometry.computeBoundingBox();
      const bbox = heartGeometry.boundingBox;
      const offsetX = - (bbox.max.x + bbox.min.x) / 2;
      const offsetY = - (bbox.max.y + bbox.min.y) / 2;
      const offsetZ = - (bbox.max.z + bbox.min.z) / 2;
      heartMesh.geometry.translate(offsetX, offsetY, offsetZ);

      heartMesh.position.y = -0.3;
      scene.add(heartMesh);

      // Corazones pequeños (misma forma y extrusión, pero más chicos)
      const smallHearts = [];
      for(let i=0; i<40; i++) {
        const smallGeometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
        // Centrar igual que el grande
        smallGeometry.computeBoundingBox();
        const b = smallGeometry.boundingBox;
        const ox = - (b.max.x + b.min.x) / 2;
        const oy = - (b.max.y + b.min.y) / 2;
        const oz = - (b.max.z + b.min.z) / 2;
        smallGeometry.translate(ox, oy, oz);

        const mat = new THREE.MeshPhongMaterial({
          color: 0xffa3b1,
          transparent: true,
          opacity: 0.25 + Math.random()*0.6,
          shininess: 80,
          specular: 0xffc0cb,
          flatShading: false,
        });

        const mesh = new THREE.Mesh(smallGeometry, mat);
        mesh.scale.setScalar(0.12 + Math.random()*0.25);
        mesh.position.set(
          (Math.random()-0.5)*8,
          (Math.random()-0.2)*6,
          (Math.random()-0.5)*8
        );
        mesh.rotation.set(
          Math.random()*Math.PI,
          Math.random()*Math.PI,
          Math.random()*Math.PI
        );

        scene.add(mesh);
        smallHearts.push(mesh);
      }

      // Partículas sutiles fondo
      const particleCount = 200;
      const particlesGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount*3);
      for(let i=0; i<particleCount; i++){
        positions[i*3] = (Math.random()-0.5)*20;
        positions[i*3+1] = (Math.random()-0.5)*10;
        positions[i*3+2] = (Math.random()-0.5)*20;
      }
      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
      const particlesMaterial = new THREE.PointsMaterial({
        color: 0xffc0cb,
        size: 0.07,
        transparent: true,
        opacity: 0.08
      });
      const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
      scene.add(particleSystem);

      // Animación
      const clock = new THREE.Clock();

      function animate(){
        requestAnimationFrame(animate);
        const elapsed = clock.getElapsedTime();

        // Corazón grande: latido y giro lento
        const scale = 1 + 0.05*Math.sin(elapsed*2);
        heartMesh.scale.set(scale, scale, scale);
        heartMesh.rotation.y += 0.005;

        // Corazones pequeños: flotan y giran suavemente
        smallHearts.forEach((h, i) => {
          h.position.x += 0.001*Math.sin(elapsed + i);
          h.position.y += 0.0007*Math.cos(elapsed*1.2 + i);
          h.position.z += 0.001*Math.sin(elapsed*0.8 + i*1.3);
          h.rotation.x += 0.005 + 0.003*Math.sin(elapsed + i);
          h.rotation.y += 0.004 + 0.004*Math.cos(elapsed*1.3 + i);
        });

        // Partículas suben lentamente
        const pos = particlesGeometry.attributes.position.array;
        for(let i=0; i<particleCount; i++){
          pos[i*3+1] += 0.0002;
          if(pos[i*3+1] > 5) pos[i*3+1] = -5;
        }
        particlesGeometry.attributes.position.needsUpdate = true;

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    })();
  </script>
</body>
</html>
