<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Te amo infinitamente Cele ❤️</title>
  <style>
    /* Reset y estilos base */
    body, html {
      margin: 0; padding: 0; overflow: hidden;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #1e1e2f 0%, #12121b 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #f8e8f8;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    /* Texto en el centro */
    #centerText {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2.4rem;
      font-style: italic;
      font-weight: 600;
      color: #fddde6;
      text-align: center;
      max-width: 320px;
      text-shadow:
        0 0 8px rgba(255,192,203,0.9),
        0 0 16px rgba(255,105,180,0.6);
      pointer-events: none;
      animation: textGlow 4s ease-in-out infinite;
      line-height: 1.3;
      font-family: 'Dancing Script', cursive;
    }

    @keyframes textGlow {
      0%, 100% {
        text-shadow:
          0 0 8px rgba(255,192,203,0.9),
          0 0 16px rgba(255,105,180,0.6);
        color: #fddde6;
      }
      50% {
        text-shadow:
          0 0 14px rgba(255,182,193,1),
          0 0 26px rgba(255,105,180,0.8);
        color: #ffc0cb;
      }
    }

    /* Importar tipografía cursiva romántica */
    @import url('https://fonts.googleapis.com/css2?family=Dancing+Script&display=swap');
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="centerText">te amo<br>infinitamente<br>cele</div>

  <!-- Three.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <!-- OrbitControls (opcional, pero no usaremos aquí) -->
  <script>
    (() => {
      // Escena y cámara
      const container = document.getElementById('container');
      const scene = new THREE.Scene();

      // Cámara perspectiva
      const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 6;

      // Renderizador
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0); // fondo transparente
      container.appendChild(renderer.domElement);

      // Luces para volumen y brillo
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
      scene.add(ambientLight);

      const pointLight1 = new THREE.PointLight(0xffa6c1, 1.1);
      pointLight1.position.set(5, 5, 5);
      scene.add(pointLight1);

      const pointLight2 = new THREE.PointLight(0xff5c8a, 0.9);
      pointLight2.position.set(-5, -5, 5);
      scene.add(pointLight2);

      // Material del corazón (degradados simulados con Phong y color rosa)
      const heartMaterial = new THREE.MeshPhongMaterial({
        color: 0xff4f79,
        shininess: 100,
        specular: 0xffaac2,
        flatShading: false,
      });

      // Geometría del corazón (usaremos un custom lathe geometry)
      function createHeartShape() {
        const shape = new THREE.Shape();

        shape.moveTo(0, 0);
        shape.bezierCurveTo(0, 0, 1, 1.2, 0, 3);
        shape.bezierCurveTo(0, 5, -3, 5, -3, 3.5);
        shape.bezierCurveTo(-3, 1.5, -1, 0, 0, 0);

        return shape;
      }

      // Para hacer volumen, hacemos lathe (rotación de perfil)
      const points = [];

      // Perfil del corazón en 2D para lathe
      // (Es un perfil vertical que al rotar forma volumen)
      points.push(new THREE.Vector2(0, 0));
      points.push(new THREE.Vector2(0.6, 0.1));
      points.push(new THREE.Vector2(1, 0.4));
      points.push(new THREE.Vector2(1.2, 1.2));
      points.push(new THREE.Vector2(0.8, 1.8));
      points.push(new THREE.Vector2(0.4, 2.3));
      points.push(new THREE.Vector2(0.15, 2.8));
      points.push(new THREE.Vector2(0, 3));

      const heartGeometry = new THREE.LatheGeometry(points, 64);
      const heartMesh = new THREE.Mesh(heartGeometry, heartMaterial);

      heartMesh.position.y = -0.5;

      scene.add(heartMesh);

      // Corazones pequeños (partículas volumétricas)
      const smallHearts = [];
      const smallHeartGeometry = new THREE.SphereGeometry(0.08, 8, 8);
      const smallHeartMaterial = new THREE.MeshPhongMaterial({
        color: 0xffa3b1,
        transparent: true,
        opacity: 0.6,
        shininess: 80,
        specular: 0xffc0cb
      });

      for (let i = 0; i < 40; i++) {
        const sh = new THREE.Mesh(smallHeartGeometry, smallHeartMaterial.clone());
        sh.position.set(
          (Math.random() - 0.5) * 8,
          (Math.random() - 0.2) * 6,
          (Math.random() - 0.5) * 8
        );
        sh.material.opacity = 0.3 + Math.random() * 0.7;
        sh.scale.setScalar(0.3 + Math.random() * 0.5);
        scene.add(sh);
        smallHearts.push(sh);
      }

      // Partículas muy sutiles de fondo (usamos puntos)
      const particleCount = 200;
      const particlesGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 20;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 20;
      }

      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const particlesMaterial = new THREE.PointsMaterial({
        color: 0xffc0cb,
        size: 0.07,
        transparent: true,
        opacity: 0.08
      });

      const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
      scene.add(particleSystem);

      // Variables para animación
      let clock = new THREE.Clock();

      // Animación: latido y giro suave del corazón grande
      function animate() {
        requestAnimationFrame(animate);

        const elapsed = clock.getElapsedTime();

        // Latido (escalar corazón entre 0.95 y 1.05)
        const scale = 1 + 0.05 * Math.sin(elapsed * 2);
        heartMesh.scale.set(scale, scale, scale);

        // Giro lento sobre eje Y
        heartMesh.rotation.y += 0.005;

        // Corazones pequeños se mueven y giran sutilmente
        smallHearts.forEach((sh, i) => {
          sh.position.x += 0.001 * Math.sin(elapsed + i);
          sh.position.y += 0.0007 * Math.cos(elapsed * 1.2 + i);
          sh.position.z += 0.001 * Math.sin(elapsed * 0.8 + i * 1.3);
          sh.rotation.x += 0.005 + 0.003 * Math.sin(elapsed + i);
          sh.rotation.y += 0.004 + 0.004 * Math.cos(elapsed * 1.3 + i);
        });

        // Partículas se mueven muy lento hacia arriba
        const positions = particlesGeometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
          positions[i * 3 + 1] += 0.0002;
          if (positions[i * 3 + 1] > 5) {
            positions[i * 3 + 1] = -5;
          }
        }
        particlesGeometry.attributes.position.needsUpdate = true;

        renderer.render(scene, camera);
      }

      animate();

      // Responsivo
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    })();
  </script>
</body>
</html>
