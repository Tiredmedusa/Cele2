<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Te amo infinitamente Cele ❤️</title>
  <style>
    body, html {
      margin: 0; padding: 0; overflow: hidden;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #1e1e2f 0%, #12121b 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #f8e8f8;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    #centerText {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2.4rem;
      font-style: italic;
      font-weight: 600;
      color: #fddde6;
      text-align: center;
      max-width: 320px;
      text-shadow:
        0 0 8px rgba(255,192,203,0.9),
        0 0 16px rgba(255,105,180,0.6);
      pointer-events: none;
      animation: textGlow 4s ease-in-out infinite;
      line-height: 1.3;
      font-family: 'Dancing Script', cursive;
    }

    @keyframes textGlow {
      0%, 100% {
        text-shadow:
          0 0 8px rgba(255,192,203,0.9),
          0 0 16px rgba(255,105,180,0.6);
        color: #fddde6;
      }
      50% {
        text-shadow:
          0 0 14px rgba(255,182,193,1),
          0 0 26px rgba(255,105,180,0.8);
        color: #ffc0cb;
      }
    }

    @import url('https://fonts.googleapis.com/css2?family=Dancing+Script&display=swap');
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="centerText">te amo<br>infinitamente<br>cele</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script>
    (() => {
      const container = document.getElementById('container');
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 6;

      const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0);
      container.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
      scene.add(ambientLight);

      const pointLight1 = new THREE.PointLight(0xffa6c1, 1.1);
      pointLight1.position.set(5,5,5);
      scene.add(pointLight1);

      const pointLight2 = new THREE.PointLight(0xff5c8a, 0.9);
      pointLight2.position.set(-5,-5,5);
      scene.add(pointLight2);

      // Función para crear forma 2D de corazón
      function createHeartShape() {
        const shape = new THREE.Shape();
        shape.moveTo(0, 0);
        shape.bezierCurveTo(0, 0, 1, 1.2, 0, 3);
        shape.bezierCurveTo(0, 5, -3, 5, -3, 3.5);
        shape.bezierCurveTo(-3, 1.5, -1, 0, 0, 0);
        return shape;
      }

      // Crear geometría lathe para volumen 3D del corazón grande
      const points = [];
      points.push(new THREE.Vector2(0, 0));
      points.push(new THREE.Vector2(0.6, 0.1));
      points.push(new THREE.Vector2(1, 0.4));
      points.push(new THREE.Vector2(1.2, 1.2));
      points.push(new THREE.Vector2(0.8, 1.8));
      points.push(new THREE.Vector2(0.4, 2.3));
      points.push(new THREE.Vector2(0.15, 2.8));
      points.push(new THREE.Vector2(0, 3));
      const heartGeometry = new THREE.LatheGeometry(points, 64);

      const heartMaterial = new THREE.MeshPhongMaterial({
        color: 0xff4f79,
        shininess: 100,
        specular: 0xffaac2,
        flatShading: false,
      });
      const heartMesh = new THREE.Mesh(heartGeometry, heartMaterial);
      heartMesh.position.y = -0.5;
      scene.add(heartMesh);

      // Geometría de corazón pequeña (extrusión de la forma 2D)
      const heartShape = createHeartShape();
      const extrudeSettings = { depth: 0.15, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.07, bevelSegments: 3 };
      const smallHeartGeometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);

      const smallHearts = [];
      for(let i=0; i<40; i++){
        const mat = new THREE.MeshPhongMaterial({
          color: 0xffa3b1,
          transparent: true,
          opacity: 0.3 + Math.random()*0.7,
          shininess: 80,
          specular: 0xffc0cb,
          flatShading: false,
        });
        const mesh = new THREE.Mesh(smallHeartGeometry, mat);
        mesh.scale.setScalar(0.15 + Math.random()*0.25);
        mesh.position.set(
          (Math.random()-0.5)*8,
          (Math.random()-0.2)*6,
          (Math.random()-0.5)*8
        );
        mesh.rotation.set(
          Math.random()*Math.PI,
          Math.random()*Math.PI,
          Math.random()*Math.PI
        );
        scene.add(mesh);
        smallHearts.push(mesh);
      }

      // Partículas fondo (puntos sutiles)
      const particleCount = 200;
      const particlesGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount*3);
      for(let i=0;i<particleCount;i++){
        positions[i*3] = (Math.random()-0.5)*20;
        positions[i*3+1] = (Math.random()-0.5)*10;
        positions[i*3+2] = (Math.random()-0.5)*20;
      }
      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
      const particlesMaterial = new THREE.PointsMaterial({
        color: 0xffc0cb,
        size: 0.07,
        transparent: true,
        opacity: 0.08
      });
      const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
      scene.add(particleSystem);

      const clock = new THREE.Clock();

      function animate(){
        requestAnimationFrame(animate);
        const elapsed = clock.getElapsedTime();

        // Corazón grande: latido + giro lento
        const scale = 1 + 0.05*Math.sin(elapsed*2);
        heartMesh.scale.set(scale,scale,scale);
        heartMesh.rotation.y += 0.005;

        // Corazones pequeños: flotan y giran suavemente
        smallHearts.forEach((h,i)=>{
          h.position.x += 0.001*Math.sin(elapsed + i);
          h.position.y += 0.0007*Math.cos(elapsed*1.2 + i);
          h.position.z += 0.001*Math.sin(elapsed*0.8 + i*1.3);
          h.rotation.x += 0.005 + 0.003*Math.sin(elapsed + i);
          h.rotation.y += 0.004 + 0.004*Math.cos(elapsed*1.3 + i);
        });

        // Partículas suben lentamente
        const pos = particlesGeometry.attributes.position.array;
        for(let i=0;i<particleCount;i++){
          pos[i*3+1] += 0.0002;
          if(pos[i*3+1]>5) pos[i*3+1] = -5;
        }
        particlesGeometry.attributes.position.needsUpdate = true;

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener('resize', ()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    })();
  </script>
</body>
</html>
